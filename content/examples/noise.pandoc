How does noise affect the fit?
Animations can help us explore this question.

We can start with a known function, and add noise.
Then we can fit the noisy data with a Gaussian Process model, and see how well our fit (with its uncertainty) covers the known true function.
If we repeat this exercise many times, it conveys an idea of the reliability of the fit.

Animations take this one step further, because they let us change the noise smoothly and continuously.
We still see many possible versions of the data, but now we also see something new: we can watch the fit evolve in response to the evolution of the noise.

<div id='test_plotly' style='width:600px;height:400px;'></div>

<script type='text/javascript'>
function createHardcodedTestDataset()
{
  var x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20];
  var y = [0, 1.5, 2, 1.5, 0, -1.5, -2, -1.5, 0, 1.5, 2, 1.5, 0, -1.5, -2, -1.5, 0, 1.5, 2, 1.5];
  var error_y = [0.2, 0.2, 0.2, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1];
  var y1 = [0, 0.6, 0.8, 0.6, 0, -0.6, -0.8, -0.6, 0, 0.6, 0.8, 0.6, 0, -0.6, -0.8, -0.6, 0, 0.6, 0.8, 0.6];

  function advance()
  {
    for (var i = 0, i_stop = y.length; i < i_stop; ++i)
    {
      y[i] *= -0.8;
      y1[i] *= 0.9;
      y1[i] += 0.1;
    }
  }

  return {
    data: {
      x: x,
      y: y,
      error_y: error_y,
      y1: y1,
    },
    advance: advance,
  };
}

function createHardcodedPlotSpecs(dataset)
{
  var traces = [
    {
      type: 'scatter',
      x: dataset.data.x,
      y: dataset.data.y,
      error_y: {
        type: 'data',
        array: dataset.data.error_y,
      },
    },{
      type: 'scatter',
      x: dataset.data.x,
      y: dataset.data.y1,
      fill: 'tonexty',
      mode: 'markers',
    }];

  return {
    traces: traces,
    advance_data: dataset.advance,
  }; 
}

function createAnimatedPlot(plot, frame_duration) {
  var animation_id = undefined;

  function stop()
  {
    if (!!animation_id)
    {
      cancelAnimationFrame(animation_id)
      animation_id = undefined;
    }
  }

  function start()
  {
    animation_id = requestAnimationFrame(timestamp => _update(timestamp, timestamp));
  }

  function _update(timestamp, next_timestamp)
  {
    if (timestamp >= next_timestamp)
    {
      next_timestamp += frame_duration;
      plot.animateToNextFrame(frame_duration);
    }

    if (!plot.finished())
    {
      animation_id = requestAnimationFrame(timestamp => _update(timestamp, next_timestamp));
    }
  }

  start();

  return {
    start: start,
    stop: stop,
  };
}

function createPlotlyPlot(div_id, specs, times_left)
{
  function animateToNextFrame(duration)
  {
    specs.advance_data();

    Plotly.animate(
      div_id,
      { data: specs.traces, },
      {
        transition: {
          duration: duration,
          easing: 'linear',
        },
        frame: {
          duration: duration,
          redraw: finished(),
        },
      });
  }

  function finished()
  {
    return (times_left <= 0);
  }

  Plotly.react(div_id, specs.traces);

  return {
    animateToNextFrame: animateToNextFrame,
    finished: finished,
  };
}

var dataset = createHardcodedTestDataset();
var specs = createHardcodedPlotSpecs(dataset);
var plot = createPlotlyPlot('test_plotly', specs, 20);
var animation = createAnimatedPlot(plot, 1000)

</script>
