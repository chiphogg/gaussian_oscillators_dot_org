How does noise affect the fit?
Animations can help us explore this question.

We can start with a known function, and add noise.
Then we can fit the noisy data with a Gaussian Process model, and see how well our fit (with its uncertainty) covers the known true function.
If we repeat this exercise many times, it conveys an idea of the reliability of the fit.

Animations take this one step further, because they let us change the noise smoothly and continuously.
We still see many possible versions of the data, but now we also see something new: we can watch the fit evolve in response to the evolution of the noise.

<div id='test_plotly' style='width:640px;height:480px;'></div>

<script type='text/javascript'>
function createHardcodedTestDataset()
{
  var x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
  var y = [0, 1.5, 2, 1.5, 0, -1.5, -2, -1.5, 0, 1.5, 2, 1.5, 0, -1.5, -2, -1.5, 0, 1.5, 2, 1.5];
  var error_y = [0.2, 0.2, 0.2, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1];
  var y1 = [0, 0.6, 0.8, 0.6, 0, -0.6, -0.8, -0.6, 0, 0.6, 0.8, 0.6, 0, -0.6, -0.8, -0.6, 0, 0.6, 0.8, 0.6];

  function advance()
  {
    for (var i = 0, i_stop = y.length; i < i_stop; ++i)
    {
      y[i] *= -0.8;
      y1[i] *= 0.9;
      y1[i] += 0.1;
    }
  }

  return {
    data: {
      x: x,
      y: y,
      error_y: error_y,
      y1: y1,
    },
    advance: advance,
  };
}

function augment(dataset, augmentations)
{
  // Make a shallow copy of the references: we want to stay up to date on
  // changes in the data, but we don't want to change the entries in the
  // "parent" dataset.
  var data = Object.assign({}, dataset.data)

  function _shortest_length(keys)
  {
    return Math.min(...keys.map(k => data[k].length));
  }

  function _apply_augmentation(label, aug)
  {
    if (!data[label])
    {
      data[label] = [];
    }

    for (var i = 0, i_stop = _shortest_length(aug.vars); i < i_stop; ++i)
    {
      data[label][i] = aug.xform(aug.vars.map(k => data[k][i]))
    }
  }

  function _update_derived_data()
  {
    Object.entries(augmentations).forEach(([label, aug]) => _apply_augmentation(label, aug));
  }

  function advance()
  {
    dataset.advance();

    _update_derived_data()
  }

  _update_derived_data()

  return {
    data: data,
    advance: advance,
  };
}

function createHardcodedPlotSpecs(dataset)
{
  var traces = [
    {
      type: 'scatter',
      x: dataset.data.x,
      y: dataset.data.y,
      error_y: {
        type: 'data',
        array: dataset.data.error_y,
      },
      line: { simplify: false, },
    },{
      type: 'scatter',
      x: dataset.data.x,
      y: dataset.data.y1,
      fill: 'tonexty',
      mode: 'markers',
      line: { simplify: false, },
    },{
      type: 'scatter',
      x: dataset.data.x,
      y: dataset.data.ymin,
      showlegend: false,
      line: { width: 0.5, color: 'gray', simplify: false, },
    },{
      type: 'scatter',
      x: dataset.data.x,
      y: dataset.data.ymax,
      fill: 'tonexty',
      line: { width: 0.5, color: 'gray', simplify: false, },
    }];

  return {
    traces: traces,
    advance_data: dataset.advance,
  }; 
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Animation code

function createAnimatedPlot(plot, frame_duration) {
  var animation_id = undefined;

  function stop()
  {
    if (!!animation_id)
    {
      cancelAnimationFrame(animation_id)
      animation_id = undefined;
    }
  }

  function start()
  {
    animation_id = requestAnimationFrame(timestamp => _update(timestamp, timestamp));
  }

  function _update(timestamp, next_timestamp)
  {
    if (timestamp >= next_timestamp)
    {
      next_timestamp += frame_duration;
      plot.animateToNextFrame(frame_duration);
    }

    animation_id = requestAnimationFrame(timestamp => _update(timestamp, next_timestamp));
  }

  start();

  return {
    start: start,
    stop: stop,
  };
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Generic plotting functions

// Get the aesthetic mapping from the trace, defaulting to the label itself.
function getAes(trace, label)
{
  return (trace['aes'] && trace['aes'][label]) || label;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Plotly-specific code

// Convert ribbon specs into plotly format.
//
// Aesthetics: x, ymin, ymax.
function createPlotlyRibbonTraces(trace, dataset)
{
  return [
    {
      type: 'scatter',
      x: dataset.data[getAes(trace, 'x')],
      y: dataset.data[getAes(trace, 'ymin')],
      showlegend: false,
      line: { width: 0, simplify: false, },
    },
    {
      type: 'scatter',
      x: dataset.data[getAes(trace, 'x')],
      y: dataset.data[getAes(trace, 'ymax')],
      fill: 'tonexty',
      fillcolor: trace.fill,
      line: { width: 0, simplify: false, },
    },
  ];
}

function getPlotlyTraceConverter(type)
{
  switch (type)
  {
    case 'ribbon':
      return createPlotlyRibbonTraces;
    default:
      alert('Type "${type}" not yet supported for plotly!');
  };
}

function createPlotlyTraces(specs)
{
  plotly_specs = specs.traces.map(t => getPlotlyTraceConverter(t.type)(t, specs.data));

  // Some plotly specs need multiple plotly traces to work (e.g., ribbon plots).
  // So, we flatten the result, in case any elements are actually arrays.
  return plotly_specs.reduce((result, val) => result.concat(val), []);;
}

function createPlotlyPlot(div_id, specs)
{
  var traces = createPlotlyTraces(specs);

  function animateToNextFrame(duration)
  {
    specs.data.advance();

    Plotly.animate(
      div_id,
      { data: traces, },
      {
        transition: {
          duration: duration,
          easing: 'linear',
        },
        frame: {
          duration: duration,
          redraw: false,
        },
      });
  }

  Plotly.react(div_id, traces);

  return {
    animateToNextFrame: animateToNextFrame,
  };
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Defining the figure

var dataset = augment(
  createHardcodedTestDataset(),
  {
    ymin: {vars: ['y', 'error_y'], xform: ([y, error_y]) => y - error_y},
    ymax: {vars: ['y', 'error_y'], xform: ([y, error_y]) => y + error_y},
  });

var specs = {
  data: dataset,
  traces: [
    {
      type: 'ribbon',
      fill: 'green',
    },
  ],
};

var plot = createPlotlyPlot('test_plotly', specs);
var animation = createAnimatedPlot(plot, 1000)

</script>
