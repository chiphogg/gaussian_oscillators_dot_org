How does noise affect the fit?
Animations can help us explore this question.

We can start with a known function, and add noise.
Then we can fit the noisy data with a Gaussian Process model, and see how well our fit (with its uncertainty) covers the known true function.
If we repeat this exercise many times, it conveys an idea of the reliability of the fit.

Animations take this one step further, because they let us change the noise smoothly and continuously.
We still see many possible versions of the data, but now we also see something new: we can watch the fit evolve in response to the evolution of the noise.

<div id='test_noise' style='width:640px;height:480px;'></div>

<script type='text/javascript'>

function gpAugmentation(k_func, label)
{
  var sqrt_matrix;

  function update_derived_data(data)
  {
    if (!data[label])
    {
      data[label] = [];
    }

    _update_sqrt_matrix(data);
    Object.assign(
      data[label], 
      jStat(data.noise).multiply(sqrt_matrix)[0]);
  }

  function _update_sqrt_matrix(data)
  {
    // If it exists, we assume it's up to date for performance reasons.
    if (!!sqrt_matrix) { return; }

    sqrt_matrix = SymmetricSquareRoot(CovarianceMatrix(data.x, k_func));
  }

  return {
    update_derived_data: update_derived_data,
  };
}

// Add two matrices.
function addMatrices(a, b)
{
  return a.map(function(a_i, i) {
    return a_i.map(function(a_ij, j) { return a_ij + b[i][j]; });
  });
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// Gaussian oscillator code

function createCompactSupportOscillators(n, n_t) {
  // A matrix of independent normal samples with n_t rows.
  // At every stage, we will replace the oldest row with brand new samples.
  var random_matrix = jStat.create(n_t, n, () => jStat.normal.sample(0, 1));
  // A matrix where each row is equivalent to the previous, but shifted by one.
  var L_t = LoopingCholesky(CompactSupportCovarianceMatrix(n_t));
  // The row of L_t which holds the vector to use.
  var i = 0;

  var noise = [];

  function setNoise()
  {
    Object.assign(noise, jStat(L_t[i]).multiply(random_matrix)[0]);
  }
  setNoise();

  function advance()
  {
    i = (i + 1) % n_t;
    if (i == 0)
    {
    }
    setNoise();
  }

  return {
    data: { noise: noise, },
    advance: advance,
  };
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Animation code

function createAnimatedPlot(plot, frame_duration) {
  var animation_id = undefined;

  function stop()
  {
    if (!!animation_id)
    {
      cancelAnimationFrame(animation_id)
      animation_id = undefined;
    }
  }

  function start()
  {
    animation_id = requestAnimationFrame(timestamp => _update(timestamp, timestamp));
  }

  function _update(timestamp, next_timestamp)
  {
    if (timestamp >= next_timestamp)
    {
      next_timestamp += frame_duration;
      plot.animateToNextFrame(frame_duration);
    }

    animation_id = requestAnimationFrame(timestamp => _update(timestamp, next_timestamp));
  }

  function toggle()
  {
    if (!!animation_id) { stop(); } else { start(); }
  }

  start();

  return {
    start: start,
    stop: stop,
    toggle: toggle,
  };
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Generic plotting functions

// Get the aesthetic mapping from the trace, defaulting to the label itself.
function getAes(trace, label)
{
  return (trace['aes'] && trace['aes'][label]) || label;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Plotly-specific code

// Convert ribbon specs into plotly format.
//
// Aesthetics: x, ymin, ymax.
function createPlotlyRibbonTraces(trace, dataset)
{
  return [
    {
      y: dataset.data[getAes(trace, 'ymin')],
      showlegend: false,
    },
    {
      y: dataset.data[getAes(trace, 'ymax')],
      fill: 'tonexty',
      fillcolor: trace.fill,
    },
  ].map(d => Object.assign({
    type: 'scatter',
    x: dataset.data[getAes(trace, 'x')],
    line: { width: 0, simplify: false, },
  }, d));
}

// Convert line specs into plotly format.
//
// Aesthetics: x, ymin, ymax.
function createPlotlyLineTrace(trace, dataset)
{
  return {
    type: 'scatter',
    x: dataset.data[getAes(trace, 'x')],
    y: dataset.data[getAes(trace, 'y')],
    line: { simplify: false, },
  };
}

// Convert point specs into plotly format.
//
// Aesthetics: x, ymin, ymax.
function createPlotlyPointTrace(trace, dataset)
{
  return Object.assign(createPlotlyLineTrace(trace, dataset), { mode: 'markers', });
}

function getPlotlyTraceConverter(type)
{
  switch (type)
  {
    case 'ribbon':
      return createPlotlyRibbonTraces;
    case 'line':
      return createPlotlyLineTrace;
    case 'point':
      return createPlotlyPointTrace;
    default:
      alert(`Type "${type}" not yet supported for plotly!`);
  };
}

function createPlotlyTraces(specs)
{
  plotly_specs = specs.traces.map(t => getPlotlyTraceConverter(t.type)(t, specs.data));

  // Some plotly specs need multiple plotly traces to work (e.g., ribbon plots).
  // So, we flatten the result, in case any elements are actually arrays.
  return plotly_specs.reduce((result, val) => result.concat(val), []);;
}

function getOrUndef(o, key, ...keys)
{
  if (!o[key])
  {
    return undefined;
  }
  if (!keys.length)
  {
    return o[key];
  }
  return getOrUndef(o[key], ...keys);
}

function createPlotlyLayout(specs)
{
  return {
    yaxis: {
      range: getOrUndef(specs, 'config', 'range', 'y')
    },
  };
}

function createPlotlyPlot(div_id, specs)
{
  var traces = createPlotlyTraces(specs);
  var layout = createPlotlyLayout(specs);

  function animateToNextFrame(duration)
  {
    specs.data.advance();

    Plotly.animate(
      div_id,
      { data: traces, },
      {
        transition: {
          duration: duration,
          easing: 'linear',
        },
        frame: {
          duration: duration,
          redraw: false,
        },
      });
  }

  Plotly.react(div_id, traces, layout);

  return {
    animateToNextFrame: animateToNextFrame,
  };
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Defining the figure

var num_pts = 60;
var noisy_dataset = combine([
  createCompactSupportOscillators(num_pts, 40),
  staticDataset({x: xRange(0, 4, num_pts)}),
]);

var new_specs = {
  data: noisy_dataset,
  traces: [
    { type: 'line', aes: { y: 'noise', } },
  ],
};

var plot = createPlotlyPlot('test_noise', new_specs);
var animation = createAnimatedPlot(plot, 250)

</script>

<script type='text/javascript'>
handleKeyPress = function(e) {
  e = e || window.event;
  switch (String.fromCharCode(e.keyCode)) {
    case 'p':
      animation.toggle();
      break;
    default:
      return;
  }
}

document.addEventListener("keypress", handleKeyPress, false);
</script>
